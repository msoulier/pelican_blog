<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>But I Digress</title><link>http://www.but-i-digress.ca/</link><description></description><atom:link href="http://feeds.feedburner.com/feeds/development.rss.xml" rel="self"></atom:link><lastBuildDate>Mon, 28 Dec 2015 11:00:00 -0500</lastBuildDate><item><title>A working logger</title><link>http://www.but-i-digress.ca/a-working-logger.html</link><description>&lt;p&gt;So it took some work, and likely there are better ways to do this, but this
logger satisfies my current needs in providing multiple levels of logging,
and an iostream interface to make composing strings simpler. First some
includes and definitions.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;ostream&amp;gt;
#include &amp;lt;boost/thread.hpp&amp;gt;
#include &amp;lt;boost/thread/mutex.hpp&amp;gt;

#define LOGLEVEL_TRACE 0
#define LOGLEVEL_DEBUG 10
#define LOGLEVEL_INFO 20
#define LOGLEVEL_WARN 30
#define LOGLEVEL_ERROR 40
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Then my thread-local buffer.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;extern boost::thread_specific_ptr&amp;lt;std::stringstream&amp;gt; tls_buffer;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The intention here is to &amp;quot;collect&amp;quot; logs from successive calls to the &amp;lt;&amp;lt; operator
in one line, using a thread-local buffer to prevent each thread from
stepping on one another. At the end of the line, we will then synchronize
around the write to the std::ostream and flush the buffer. There might be a
way to declare the tls_buffer inside of the class but my C++ chops are
currently insufficient.&lt;/p&gt;
&lt;p&gt;I am also aware that one could use a temporary variable hack to get a
thread-local buffer without using boost here, but the examples that I found
showing this were very hard for me to understand. This, I understand so I'm
going with it for now.&lt;/p&gt;
&lt;p&gt;Now, my logger is broken up into two classes. The main logger, and the
logger handlers that are used to do the actual logging at each level
(ie. debug, info, error, etc). This handler is where the &amp;lt;&amp;lt; operator
overloading magic happens.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;class MLoggerHandler
{
public:
    MLoggerHandler(boost::mutex&amp;amp; mutex,
                std::ostream&amp;amp; ostream,
                int threshold,
                std::string prefix);
    ~MLoggerHandler();
    void setLevel(int level);

    template &amp;lt;class T&amp;gt;
    // For handling &amp;lt;&amp;lt; from any object.
    MLoggerHandler&amp;amp; operator &amp;lt;&amp;lt;(T input) {
        // Only log if the level is set above our threshold.
        if (m_threshold &amp;gt;= m_level) {
            if (tls_buffer.get() == NULL) {
                tls_buffer.reset(new std::stringstream());
            }
            if (tls_buffer-&amp;gt;str().length() == 0) {
                *tls_buffer &amp;lt;&amp;lt; localDateTime() &amp;lt;&amp;lt; &amp;quot; &amp;quot; &amp;lt;&amp;lt; m_prefix &amp;lt;&amp;lt; &amp;quot;: &amp;quot; &amp;lt;&amp;lt; input;
            }
            else {
                *tls_buffer &amp;lt;&amp;lt; input;
            }
        }
        return *this;
    }
    // For handling std::endl
    std::ostream&amp;amp; operator &amp;lt;&amp;lt;(std::ostream&amp;amp; (*f)(std::ostream&amp;amp;)) {
        // Only log if the level is set above our threshold.
        if (m_threshold &amp;gt;= m_level) {
            boost::lock_guard&amp;lt;boost::mutex&amp;gt; lock{m_mutex};
            // Flush the buffer
            m_ostream &amp;lt;&amp;lt; tls_buffer-&amp;gt;str();
            f(m_ostream);
            // Clear the buffer
            tls_buffer-&amp;gt;str(&amp;quot;&amp;quot;);
        }
        return m_ostream;
    }
private:
    // A mutex passed in from the main logger for synchronization.
    boost::mutex&amp;amp; m_mutex;
    // The logging level.
    int m_level;
    // The output stream.
    std::ostream&amp;amp; m_ostream;
    // The threshold for logging for this handler.
    int m_threshold;
    // The string prefix for logging.
    std::string m_prefix;
    // Return the current date and time as a localized string.
    const std::string localDateTime();
};
&lt;/pre&gt;&lt;/div&gt;
&lt;!-- ** --&gt;
&lt;p&gt;Note that the &amp;lt;&amp;lt; overload takes any type capable of itself using the &amp;lt;&amp;lt;
operator, while there's a separate method required to implement handling
for the &lt;cite&gt;std::endl&lt;/cite&gt; at the end of the line. This allows us to knwo when the
line is terminated, to write and flush the buffer, but it also imposes the
limitation that the user of this logger &lt;em&gt;must&lt;/em&gt; provide the &lt;cite&gt;std::endl&lt;/cite&gt; to
terminate the line or the logger won't work properly. These handlers are
returned as a result of calling the individual level methods in the main
logger, like &lt;cite&gt;info()&lt;/cite&gt;, &lt;cite&gt;debug()&lt;/cite&gt;, etc.&lt;/p&gt;
&lt;p&gt;Also note that when the thread-local buffer is empty, that is used as an
indication of building the beginning of the line, and thus starting with
a logging level prefix and a timestamp.&lt;/p&gt;
&lt;p&gt;And now the main logger...&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;/*
* The MLogger (Mike-logger) is a thread-safe C++ logger using the iostream operators.
* To use it, you must invoke a logging level handler which will return an
* MLoggerHandler reference, and then terminate your line with std::endl to ensure
* that the buffer is flushed and the line terminated with a newline.
*/
class MLogger
{
public:
    MLogger();
    MLogger(std::string name);
    ~MLogger();
    // Set the current logging level
    void setLevel(int level);
    // Get the current logging level
    int getLevel();
    // Convenience methods for trace level log.
    MLoggerHandler&amp;amp; trace();
    // Convenience methods for debug level log
    MLoggerHandler&amp;amp; debug();
    // Convenience methods for info level log
    MLoggerHandler&amp;amp; info();
    // Convenience methods for warning level log
    MLoggerHandler&amp;amp; warn();
    // Convenicence methods for error level log
    MLoggerHandler&amp;amp; error();
private:
    // The logger name.
    std::string m_name;
    // The current log level.
    int m_level;
    // The output stream for the logger.
    std::ostream&amp;amp; m_ostream;
    // The mutex used for synchronization.
    boost::mutex m_mutex;
    // Trace handler
    MLoggerHandler m_trace_handler;
    // Debug handler
    MLoggerHandler m_debug_handler;
    // Info handler
    MLoggerHandler m_info_handler;
    // Warn handler
    MLoggerHandler m_warn_handler;
    // Error handler
    MLoggerHandler m_error_handler;
};
&lt;/pre&gt;&lt;/div&gt;
&lt;!-- ** --&gt;
&lt;p&gt;The implementation is nothing special, but for completeness here it is.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;boost::thread_specific_ptr&amp;lt;std::stringstream&amp;gt; tls_buffer;

MLoggerHandler::MLoggerHandler(boost::mutex&amp;amp; mutex,
                            std::ostream&amp;amp; ostream,
                            int threshold,
                            std::string prefix)
    : m_mutex(mutex)
    , m_level(LOGLEVEL_INFO)
    , m_ostream(ostream)
    , m_threshold(threshold)
    , m_prefix(prefix)
{ }

MLoggerHandler::~MLoggerHandler() { }

void MLoggerHandler::setLevel(int level) {
    m_level = level;
}

const std::string MLoggerHandler::localDateTime() {
    const char *format = &amp;quot;%b %d %Y @ %X %Z&amp;quot;;
    std::time_t t = std::time(NULL);
    char buffer[128];
    if (std::strftime(buffer, sizeof(buffer), format, std::localtime(&amp;amp;t))) {
        return std::string(buffer);
    }
    else {
        return &amp;quot;&amp;quot;;
    }
}

MLogger::MLogger(std::string name)
    : m_name(name)
    , m_level(LOGLEVEL_INFO)
    , m_ostream(std::cerr)
    , m_trace_handler(MLoggerHandler(m_mutex, m_ostream, LOGLEVEL_TRACE, &amp;quot;TRACE&amp;quot;))
    , m_debug_handler(MLoggerHandler(m_mutex, m_ostream, LOGLEVEL_DEBUG, &amp;quot;DEBUG&amp;quot;))
    , m_info_handler(MLoggerHandler(m_mutex, m_ostream, LOGLEVEL_INFO, &amp;quot;INFO&amp;quot;))
    , m_warn_handler(MLoggerHandler(m_mutex, m_ostream, LOGLEVEL_WARN, &amp;quot;WARN&amp;quot;))
    , m_error_handler(MLoggerHandler(m_mutex, m_ostream, LOGLEVEL_ERROR, &amp;quot;ERROR&amp;quot;))
    { }

MLogger::MLogger() : MLogger(&amp;quot;No name&amp;quot;) { }

MLogger::~MLogger() { }

int MLogger::getLevel() {
    return m_level;
}

void MLogger::setLevel(int level) {
    m_level = level;
    // And set it on all of the logger handlers.
    m_trace_handler.setLevel(level);
    m_debug_handler.setLevel(level);
    m_info_handler.setLevel(level);
    m_warn_handler.setLevel(level);
    m_error_handler.setLevel(level);
}

MLoggerHandler&amp;amp; MLogger::trace() {
    return m_trace_handler;
}

MLoggerHandler&amp;amp; MLogger::debug() {
    return m_debug_handler;
}

MLoggerHandler&amp;amp; MLogger::info() {
    return m_info_handler;
}

MLoggerHandler&amp;amp; MLogger::warn() {
    return m_warn_handler;
}

MLoggerHandler&amp;amp; MLogger::error() {
    return m_error_handler;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;!-- ** --&gt;
&lt;p&gt;Currently, I'm using this through a simple shared global called &lt;cite&gt;logger&lt;/cite&gt;,
so you then just use it like so:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;MLogger logger;

logger.setLevel(LOGLEVEL_INFO);

// This produces no output at INFO logging level.
logger.debug() &amp;lt;&amp;lt; &amp;quot;The current value of foo is &amp;quot; &amp;lt;&amp;lt; foo &amp;lt;&amp;lt; std::endl;

// This produces output.
logger.info() &amp;lt;&amp;lt; &amp;quot;The current value of bar is &amp;quot; &amp;lt;&amp;lt; bar &amp;lt;&amp;lt; std::endl;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So, it works, it's thread safe, and I don't have to manually build my own
logging strings with &lt;cite&gt;std::stringstream&lt;/cite&gt;, saving endless lines of code. I'm
certain that it can be improved, I can certainly build in facilities like
log rotation, compression, etc. But, it's a start.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Michael P. Soulier</dc:creator><pubDate>Mon, 28 Dec 2015 11:00:00 -0500</pubDate><guid>tag:www.but-i-digress.ca,2015-12-28:a-working-logger.html</guid><category>C++</category></item><item><title>Re-learning C++</title><link>http://www.but-i-digress.ca/re-learning-c++.html</link><description>&lt;p&gt;So lately I've been dusting off my C++ knowledge, experimenting with replacing
a daemon written in Python on the product that I work on with one written in
C++. For most Python programmers this may seem like serious masochism, but I
wanted to know just how much harder it would be to work in C++ with the new
standards, plus the boost library, with hopefully a minor loss of productivity
with a big gain in performance.&lt;/p&gt;
&lt;p&gt;I'm definitely moving slowly at first, as I re-learn use of the language,
pick up the new features, cross-check with a co-worker who works in C++ all day,
and keep the code building on both Mac OS X and Linux.&lt;/p&gt;
&lt;p&gt;To build C++ with the new 2011 standard, it's as simple as adding the &lt;cite&gt;--std=c++11&lt;/cite&gt; argument to the g++ compiler. This can be problematic if, like me, your
workplace is using a &lt;a class="reference external" href="http://www.centos.org"&gt;CentOS 6&lt;/a&gt; build environment from the Paleolithic era:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ make
g++ -Wall -Werror -I. --std=c++11 -ggdb -DLINUX -c EventWorker.cpp
cc1plus: error: unrecognized command line option &amp;quot;-std=c++11&amp;quot;
make: *** [EventWorker.o] Error 1

$ g++ --version
g++ (GCC) 4.4.7 20120313 (Red Hat 4.4.7-16)
Copyright (C) 2010 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
&lt;/pre&gt;
&lt;p&gt;GCC 4.4.7 isn't that old, but to build C++ 2011 code on Linux, I had to turn to
my Debian Jessie desktop:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ g++ --version
g++ (Debian 4.9.2-10) 4.9.2
Copyright (C) 2014 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
&lt;/pre&gt;
&lt;p&gt;This did work fine using XCode on Mac as well, although I had to use boost out
of Homebrew, so I did need to adapt my Makefile to work on both platforms.&lt;/p&gt;
&lt;p&gt;That aside, I could mainly just focus on the application, which needs to pull
JSON events from a fifo, process them, and sometimes write events into
another fifo. The current Python application runs 5 threads responsible for
various jobs. So how do I do that using C++ and boost?&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;std::ifstream input_stream;
input_stream.open(input_file, std::ios::in);

SafeQueue&amp;lt;Json::Value&amp;gt; *json_queue = new SafeQueue&amp;lt;Json::Value&amp;gt;(MAX_QUEUE_SIZE);
boost::thread reader_thread(start_reader, json_queue, &amp;amp;input_stream);

reader_thread.join();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Not too bad. That code doesn't get much shorter in Python. Mind you, the
template that I wrote for the SafeQueue most certainly does. I'll show that
soon but I want to keep these posts small.&lt;/p&gt;
&lt;p&gt;I think I could have used a synchronized queue-like something in boost, but
honestly, I find the boost documentation horrible to read, and this was the
best that I could do at the time. The start_reader function in JsonReader
isn't too bad.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    JsonReader *reader = new JsonReader(fifopath, json_queue);
    reader-&amp;gt;startReading(stream);
    logger.info(&amp;quot;JsonReader: stopping&amp;quot;);
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The logger is mine too, because I couldn't get the boost logger to link on
Mac OS X, and the error was so obscure that I couldn't figure it out. Maybe
later. The startReading method is pretty readable too.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    while (! m_stop_asap) {
        std::string line;
        std::getline(*stream, line);
        if (line.length() &amp;gt; 0) {
            msg.str(&amp;quot;&amp;quot;);
            msg &amp;lt;&amp;lt; &amp;quot;JsonReader: read &amp;quot; &amp;lt;&amp;lt; line.length() &amp;lt;&amp;lt; &amp;quot; bytes: &amp;quot; &amp;lt;&amp;lt; line;
            logger.debug(msg.str());
            msg.str(&amp;quot;&amp;quot;);
            msg &amp;lt;&amp;lt; line;
            msg &amp;gt;&amp;gt; json;
            // If the logger is in debug mode, print a nicely formatted
            // version of the json.
            if (logger.getLevel() == LOGLEVEL_DEBUG) {
                msg.str(&amp;quot;Pretty printed:&amp;quot;);
                msg &amp;lt;&amp;lt; json;
                logger.debug(msg.str());
            }
            else {
                // Just print the raw line we read.
                logger.info(msg.str());
            }
            // And enqueue the json for processing.
            m_json_queue-&amp;gt;enqueue(json);
        }
        else {
            logger.warn(&amp;quot;read nothing from input stream&amp;quot;);
            if (stream-&amp;gt;eof()) {
                logger.warn(&amp;quot;EOF detected, exiting&amp;quot;);
                return;
            }
        }
    }
    logger.info(&amp;quot;Exit of JsonReader requested.&amp;quot;);
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The longest part is just the logging, which I can reduce a great deal if I
improve the logging interface. Managing these std::stringstream objects is
a lot more work than with Python strings. But damn, is it fast so far.&lt;/p&gt;
&lt;p&gt;I'll keep you posted on how it goes. Given my learning Google Go, it's tempting
to use that, but I think I'll stick with C++ to finish my objective of
re-learning it. I have other ideas for Go.&lt;/p&gt;
&lt;p&gt;Cheers.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Michael P. Soulier</dc:creator><pubDate>Tue, 15 Dec 2015 19:00:00 -0500</pubDate><guid>tag:www.but-i-digress.ca,2015-12-15:re-learning-c++.html</guid><category>C++</category></item><item><title>Learning Google Go</title><link>http://www.but-i-digress.ca/learning-google-go.html</link><description>&lt;p&gt;So, I heard from a friend that &lt;a class="reference external" href="http://golang.org"&gt;Google Go&lt;/a&gt; was worth learning, so I've started
to look into it. I must admit, while working on updating my C++ knowledge to
account for the new &lt;a class="reference external" href="http://www.stroustrup.com/C++11FAQ.html"&gt;2011&lt;/a&gt; and &lt;a class="reference external" href="https://isocpp.org/std/status"&gt;2014&lt;/a&gt; standards, and working on learning
&lt;a class="reference external" href="http://www.boost.org"&gt;boost&lt;/a&gt;, picking up Go is a lot of fun by comparison.&lt;/p&gt;
&lt;p&gt;I'm finding that Go is filling a nice spot between say, C++ and &lt;a class="reference external" href="http://www.python.org"&gt;Python&lt;/a&gt;, as
Python is much more productive to develop in, but it's byte-compiled and does
not tend to perform anywhere near as well as C++, but C++ is filled with
language cruft, low level details that programmers usually shouldn't have to
bother with, and requires far more code typically to perform an equal task in
a higher level language.&lt;/p&gt;
&lt;p&gt;Go also has built-in multi-threading and synchronization support, in the form
of &amp;quot;goroutines&amp;quot; and &amp;quot;channels&amp;quot;. Here's a pointless example that fires up
ten goroutines, has each one count to a billion, and report back via the
passed channel.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;package&lt;/span&gt; &lt;span class="nx"&gt;main&lt;/span&gt;

&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="s"&gt;&amp;quot;fmt&amp;quot;&lt;/span&gt;
    &lt;span class="s"&gt;&amp;quot;time&amp;quot;&lt;/span&gt;
    &lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;wastetime&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;ch&lt;/span&gt; &lt;span class="kd"&gt;chan&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;start&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;time&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Now&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="c1"&gt;// Burn some time pointlessly looping&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;1000000000&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="nx"&gt;ch&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Sprintf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;took %f seconds&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;time&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Since&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;start&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="nx"&gt;Seconds&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
    &lt;span class="nx"&gt;ch&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;done&amp;quot;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;ch&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nb"&gt;make&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;chan&lt;/span&gt; &lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="nx"&gt;count&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Starting goroutine %d\n&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;go&lt;/span&gt; &lt;span class="nx"&gt;wastetime&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;ch&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nx"&gt;s&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Sprintf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;%s&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt;&lt;span class="nx"&gt;ch&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nx"&gt;s&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;done&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;%d goroutine done\n&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;count&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="nx"&gt;count&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;%s\n&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nx"&gt;count&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="k"&gt;break&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Once you get the syntax down, it's not bad at all. The left arrow operator
is reading from or writing to the channel, which blocks until the goroutine
on the other end does its part. It's like using threads and queues in other
languages, but a tad higher level and simpler. Should be fun to continue
learning. And it's compiled and fast:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
Starting goroutine 1
Starting goroutine 2
Starting goroutine 3
Starting goroutine 4
Starting goroutine 5
Starting goroutine 6
Starting goroutine 7
Starting goroutine 8
Starting goroutine 9
Starting goroutine 10
took 0.663542 seconds
10 goroutine done
took 0.663968 seconds
9 goroutine done
took 0.658279 seconds
8 goroutine done
took 0.663875 seconds
7 goroutine done
took 0.652669 seconds
6 goroutine done
took 0.645463 seconds
5 goroutine done
took 0.652085 seconds
4 goroutine done
took 0.655896 seconds
3 goroutine done
took 0.357376 seconds
2 goroutine done
took 0.342241 seconds
1 goroutine done
&lt;/pre&gt;
&lt;p&gt;Neat huh? More to come, I suspect.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Michael P. Soulier</dc:creator><pubDate>Tue, 15 Dec 2015 16:00:00 -0500</pubDate><guid>tag:www.but-i-digress.ca,2015-12-15:learning-google-go.html</guid><category>Go</category></item><item><title>Checking the weather</title><link>http://www.but-i-digress.ca/checking-the-weather.html</link><description>&lt;p&gt;A while back I needed a way to check the weather forecast, simply, from a
terminal, as is the preference of most Unix geeks like me. Being a Canadian,
I'm not interested in the Weather Channel as much as the Environment Canada
data. Thankfully, they do publish an RSS feed, and good for them.&lt;/p&gt;
&lt;p&gt;I'm interested in this one:
&lt;a class="reference external" href="http://www.weatheroffice.gc.ca/rss/city/on-118_e.xml"&gt;http://www.weatheroffice.gc.ca/rss/city/on-118_e.xml&lt;/a&gt;. So, to check the
weather, I need to pull the feed and parse it. Pulling a page in Python is as
simple as using &lt;tt class="docutils literal"&gt;urllib&lt;/tt&gt;. From there, I can walk the elements I want like
so:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;urllib&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;xml.etree.ElementTree&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;parse&lt;/span&gt;

&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;elem&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;parse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;urllib&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;urlopen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rssfeed&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;findall&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;channel/item/title&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now, I wanted the option of picking a certain number of lines, and wrapping at
a certain number of columns. I wanted this for using the script output as
input into other apps, like &lt;a class="reference external" href="http://conky.sourceforge.net/"&gt;Conky&lt;/a&gt;. Skipping lines is easy, intelligently
wrapping them is not. Luckily, Python has a &lt;tt class="docutils literal"&gt;textwrap&lt;/tt&gt; module in the
standard library.&lt;/p&gt;
&lt;p&gt;You use it like this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;textwrap&lt;/span&gt;

&lt;span class="n"&gt;wrapper&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;textwrap&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;TextWrapper&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;width&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;options&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;wrap&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;subsequent_indent&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;    &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;lines&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wrapper&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;wrap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;lines&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Put together, it's really that simple. I think the majority of my code is
option parsing. The core loop is just this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;options&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;parse_options&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;wrapper&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;textwrap&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;TextWrapper&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;width&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;options&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;wrap&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;subsequent_indent&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;    &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;count&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;elem&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;parse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;urllib&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;urlopen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rssfeed&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;findall&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;channel/item/title&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;elem&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;text&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;encode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;utf8&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;ignore&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;lines&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wrapper&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;wrap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;lines&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;count&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;options&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;lines&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;options&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;lines&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;break&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;continue&lt;/span&gt;
    &lt;span class="k"&gt;break&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The whole thing &lt;a class="reference external" href="https://github.com/msoulier/mikes-tools/blob/master/weather.py"&gt;is here&lt;/a&gt;. Sample output looks like this:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
No watches or warnings in effect, Ottawa (Kanata - Orléans)
Current Conditions: Light Snow, -11.1°C
Sunday night: A few flurries. Low minus 18.
Monday: Sunny. High minus 9.
Monday night: Increasing cloudiness. Low minus 12.
Tuesday: Chance of flurries. High minus 7. POP 60%
Wednesday: A mix of sun and cloud. Low minus 16. High minus 8.
Thursday: Periods of snow. Low minus 8. High minus 2.
Friday: Sunny. Low minus 12. High minus 7.
Saturday: Periods of snow. Low minus 12. High minus 7.
&lt;/pre&gt;
&lt;p&gt;I love building my own tools like this, it's the ultimate in end-user
computing. Unix and Python are my playground.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Michael P. Soulier</dc:creator><pubDate>Sun, 23 Dec 2012 20:30:00 -0500</pubDate><guid>tag:www.but-i-digress.ca,2012-12-23:checking-the-weather.html</guid><category>Python</category></item><item><title>Getting started with autotools</title><link>http://www.but-i-digress.ca/getting-started-with-autotools.html</link><description>&lt;p&gt;So, I'm still reading O'Rielly's &lt;a class="reference external" href="http://www.but-i-digress.ca/21st-century-c.html"&gt;21st Century C&lt;/a&gt;. I know, too many books on
the go and I read slowly, and not often enough. I'm going through the section
on &lt;a class="reference external" href="http://www.gnu.org/software/autoconf/"&gt;GNU autotools&lt;/a&gt;, which I've never been a heavy user of, albiet I'm a heavy
consumer of. I just don't spend much time distributing C/C++ across platforms.&lt;/p&gt;
&lt;p&gt;I have a little C tool that I figured I'd try it on, a small replacement for
GNU tree that I wrote a while back, and since &lt;tt class="docutils literal"&gt;tree&lt;/tt&gt; isn't available on
OS X, it seemed a good excuse to port it. Previously I just had a Makefile
that I maintained, and it works fine, but it's a good excuse to learn how to
use autotools for the future. I do have some libraries, and they're harder to
port, which is where &lt;a class="reference external" href="http://www.gnu.org/software/libtool/"&gt;libtool&lt;/a&gt; comes in.&lt;/p&gt;
&lt;p&gt;This &lt;tt class="docutils literal"&gt;build&lt;/tt&gt; script outlines the process of using autotools for the first
time. This script borrows very heavily from the book's author.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;#!/bin/sh&lt;/span&gt;

&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Creating Makefile.am&amp;quot;&lt;/span&gt;
cat &amp;gt; Makefile.am &lt;span class="s"&gt;&amp;lt;&amp;lt;EOF&lt;/span&gt;
&lt;span class="s"&gt;bin_PROGRAMS=twig&lt;/span&gt;
&lt;span class="s"&gt;twig_SOURCES=twig.c&lt;/span&gt;
&lt;span class="s"&gt;EOF&lt;/span&gt;

&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Running autoscan...&amp;quot;&lt;/span&gt;
autoscan

&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Creating configure.ac...&amp;quot;&lt;/span&gt;
sed -e &lt;span class="s1"&gt;&amp;#39;s/FULL-PACKAGE-NAME/twig/&amp;#39;&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
    -e &lt;span class="s1"&gt;&amp;#39;s/VERSION/1.0/&amp;#39;&lt;/span&gt;   &lt;span class="se"&gt;\&lt;/span&gt;
    -e &lt;span class="s1"&gt;&amp;#39;s|BUG-REPORT-ADDRESS|msoulier@digitaltorque.ca|&amp;#39;&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
    -e &lt;span class="s1"&gt;&amp;#39;10i\&lt;/span&gt;
&lt;span class="s1"&gt;    AM_INIT_AUTOMAKE&amp;#39;&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
        &amp;lt; configure.scan &amp;gt; configure.ac

&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Creating additional files...&amp;quot;&lt;/span&gt;
touch NEWS README AUTHORS ChangeLog

&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Running autoreconf...&amp;quot;&lt;/span&gt;
autoreconf -iv

&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Running configure...&amp;quot;&lt;/span&gt;
./configure

&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Running make distcheck to package sources...&amp;quot;&lt;/span&gt;
make distcheck
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;At this point, it's not ready to ship, as the &lt;tt class="docutils literal"&gt;NEWS&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;README&lt;/tt&gt;,
&lt;tt class="docutils literal"&gt;AUTHORS&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;ChangeLog&lt;/tt&gt; aren't populated yet. But it's close. The
&lt;tt class="docutils literal"&gt;configure&lt;/tt&gt; script works, and I could then build it on OS X using the
expected.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;./configure --prefix&lt;span class="o"&gt;=&lt;/span&gt;/usr/local
make
make install
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;My next project to package is a shared library for work, so that will be more
interesting. Still, if you're looking to use autotools for the first time for
something simple, this should take the mystery out of kick-starting it. Sure,
there's some magic like the &lt;tt class="docutils literal"&gt;AM_INIT_AUTOMAKE&lt;/tt&gt; macro, and I've a ton to
learn yet, but this worked on the first try, and the resulting tarball is good
to push to &lt;a class="reference external" href="http://sourceforge.net/"&gt;SourceForge&lt;/a&gt; or elsewhere if you want to.&lt;/p&gt;
&lt;p&gt;As I pick up more, I'll try to share it. I don't find autotools intuitive at
all, but with some simple recipes I think I'll survive.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Michael P. Soulier</dc:creator><pubDate>Sun, 16 Dec 2012 08:30:00 -0500</pubDate><guid>tag:www.but-i-digress.ca,2012-12-16:getting-started-with-autotools.html</guid><category>C/C++</category><category>FOSS</category><category>Autotools</category></item><item><title>21st Century C</title><link>http://www.but-i-digress.ca/21st-century-c.html</link><description>&lt;p&gt;I saw a sale from &lt;a class="reference external" href="http://oreilly.com/"&gt;O'Reilly Publishing&lt;/a&gt; tonight on an new ebook for
&lt;a class="reference external" href="http://shop.oreilly.com/product/0636920025108.do?code=WKCPRGM"&gt;21st Century C&lt;/a&gt;. I have a good history with O'Reilly and C programming, so
it caught my attention.&lt;/p&gt;
&lt;p&gt;When I was in University, &lt;a class="reference external" href="http://shop.oreilly.com/product/9781565923065.do?code=WKCPRGM"&gt;Practical C Programming&lt;/a&gt;
taught me much more than any of my professors, and
&lt;a class="reference external" href="http://shop.oreilly.com/product/9781565921634.do"&gt;Unix System Programming for System VR4&lt;/a&gt; taught me a great deal more about
programming C on Unix/Linux. After reading those books, I became actually
comfortable in working in C for all of my assignments, and other students
kept coming to me for help until I had somehow become a local C expert.
Amazing what a good investment in reading material will do, not to mention
actually reading said material. Another friend in University taught me that.
He told me not to ever begrudge the cost of a book that helps you get better
at what you do. I've applied that lesson ever since.&lt;/p&gt;
&lt;p&gt;I relied on O'Reilly for my first introduction to C++, with
&lt;a class="reference external" href="http://shop.oreilly.com/product/9781565921160.do"&gt;C++, the Core Language&lt;/a&gt;, which finally explained to me where some of my
memory leaks were coming from, by explaining copy constructors and assignment
operators. I turned to &lt;a class="reference external" href="http://books.google.com/books/about/Beginning_C++.html?id=vtcpAQAAMAAJ"&gt;another book&lt;/a&gt; to finish most of my C++ education, but
O'Reilly got me started.&lt;/p&gt;
&lt;p&gt;Since University, with the wealth of information on the Internet, I haven't
bought many C books, but I did pick up &lt;a class="reference external" href="http://basepath.com/aup/"&gt;Advanced Unix Programming&lt;/a&gt;, second
edition, on the recommendation of a coworker, and he did not lead me astray,
the book is excellent. Mind you, I still haven't finished reading it. I seem
to buy books faster than I read them these days.&lt;/p&gt;
&lt;p&gt;Maybe one day I'll take a little vacation just to read. Anyway...&lt;/p&gt;
&lt;p&gt;Looking at the new O'Reilly book, it looks like it has many practical ideas
for someone living with C from day to day, and should also provide a nice
introduction to the new C11 standard, just released in December of last year.
Hopefully it'll sharpen my skills like previous O'Reilly books have. I'll try
to post a full review once I've finished it...err...if I finish it.&lt;/p&gt;
&lt;p&gt;I will stop buying faster than I can read. I will stop buying faster than I
can read. Maybe if I keep repeating that, it'll sink in.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Michael P. Soulier</dc:creator><pubDate>Tue, 06 Nov 2012 22:12:00 -0500</pubDate><guid>tag:www.but-i-digress.ca,2012-11-06:21st-century-c.html</guid><category>C/C++</category><category>Books</category></item></channel></rss>